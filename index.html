<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram Tetris</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #111;
            color: white;
            touch-action: manipulation;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            padding: 10px;
            text-align: center;
            background-color: #222;
        }
        
        .game-container {
            display: flex;
            flex: 1;
            padding: 10px;
            gap: 10px;
        }
        
        #tetris {
            background-color: #000;
            border: 2px solid #333;
            flex-grow: 1;
            max-width: 100%;
            max-height: calc(100vh - 150px);
        }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 120px;
        }
        
        .info-panel {
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: auto;
        }
        
        .controls button {
            aspect-ratio: 1;
            border: none;
            border-radius: 5px;
            background-color: #333;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }
        
        .controls button:active {
            background-color: #555;
        }
        
        #rotate-btn {
            grid-column: span 3;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéÆ –¢–µ—Ç—Ä–∏—Å</h1>
    </div>
    
    <div class="game-container">
        <canvas id="tetris"></canvas>
        
        <div class="sidebar">
            <div class="info-panel">
                <div>–°—á–µ—Ç: <span id="score">0</span></div>
                <div>–£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span></div>
                <div>–°–ª–µ–¥—É—é—â–∞—è:</div>
                <canvas id="next-piece" width="100" height="100"></canvas>
            </div>
            
            <div class="controls">
                <button id="left-btn">‚Üê</button>
                <button id="down-btn">‚Üì</button>
                <button id="right-btn">‚Üí</button>
                <button id="rotate-btn">‚Üª</button>
            </div>
        </div>
    </div>

    <script>
        // –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece');
        const nextCtx = nextCanvas.getContext('2d');
        
        // –†–∞–∑–º–µ—Ä—ã –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        
        // –¶–≤–µ—Ç–∞ –±–ª–æ–∫–æ–≤
        const COLORS = [
            null,
            '#FF0D72', // I
            '#0DC2FF', // J
            '#0DFF72', // L
            '#F538FF', // O
            '#FF8E0D', // S
            '#FFE138', // T
            '#3877FF'  // Z
        ];
        
        // –§–∏–≥—É—Ä—ã —Ç–µ—Ç—Ä–æ–º–∏–Ω–æ
        const SHAPES = [
            null,
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I
            [[2, 0, 0], [2, 2, 2], [0, 0, 0]],                         // J
            [[0, 0, 3], [3, 3, 3], [0, 0, 0]],                         // L
            [[0, 4, 4], [0, 4, 4], [0, 0, 0]],                         // O
            [[0, 5, 5], [5, 5, 0], [0, 0, 0]],                         // S
            [[0, 6, 0], [6, 6, 6], [0, 0, 0]],                         // T
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]]                          // Z
        ];
        
        // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let score = 0;
        let level = 1;
        let gameOver = false;
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;
        
        // –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ
        const arena = createMatrix(COLS, ROWS);
        
        // –ò–≥—Ä–æ–∫
        const player = {
            pos: {x: 0, y: 0},
            matrix: null,
            next: null
        };
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        function init() {
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ä–∞–∑–º–µ—Ä–æ–≤ canvas
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // –°–æ–∑–¥–∞–µ–º –ø–µ—Ä–≤—É—é —Ñ–∏–≥—É—Ä—É
            playerReset();
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            setupControls();
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä—É
            update();
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ä–∞–∑–º–µ—Ä–æ–≤ canvas
        function resizeCanvas() {
            const size = Math.min(window.innerWidth - 150, window.innerHeight - 150);
            canvas.width = COLS * BLOCK_SIZE;
            canvas.height = ROWS * BLOCK_SIZE;
            canvas.style.width = COLS * BLOCK_SIZE + 'px';
            canvas.style.height = ROWS * BLOCK_SIZE + 'px';
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã
        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã
        function createPiece(type) {
            return SHAPES[type];
        }
        
        // –†–∏—Å–æ–≤–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã
        function drawMatrix(matrix, offset) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect(
                            x + offset.x,
                            y + offset.y,
                            1, 1
                        );
                        
                        // –ì—Ä–∞–Ω–∏—Ü—ã –±–ª–æ–∫–æ–≤
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 0.05;
                        ctx.strokeRect(
                            x + offset.x,
                            y + offset.y,
                            1, 1
                        );
                    }
                });
            });
        }
        
        // –†–∏—Å–æ–≤–∞–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∏–≥—É—Ä—ã
        function drawNext() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            
            const matrix = player.next;
            const offset = {
                x: (nextCanvas.width / BLOCK_SIZE - matrix[0].length) / 2,
                y: (nextCanvas.height / BLOCK_SIZE - matrix.length) / 2
            };
            
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        nextCtx.fillStyle = COLORS[value];
                        nextCtx.fillRect(
                            (x + offset.x) * BLOCK_SIZE,
                            (y + offset.y) * BLOCK_SIZE,
                            BLOCK_SIZE, BLOCK_SIZE
                        );
                        
                        nextCtx.strokeStyle = '#000';
                        nextCtx.lineWidth = 1;
                        nextCtx.strokeRect(
                            (x + offset.x) * BLOCK_SIZE,
                            (y + offset.y) * BLOCK_SIZE,
                            BLOCK_SIZE, BLOCK_SIZE
                        );
                    }
                });
            });
        }
        
        // –†–∏—Å–æ–≤–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
        function draw() {
            // –û—á–∏—Å—Ç–∫–∞ canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // –†–∏—Å–æ–≤–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
            drawMatrix(arena, {x: 0, y: 0});
            
            // –†–∏—Å–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ñ–∏–≥—É—Ä—ã
            drawMatrix(player.matrix, player.pos);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
        function playerReset() {
            if (!player.next) {
                player.next = createPiece(Math.floor(Math.random() * 7) + 1);
            }
            
            player.matrix = player.next;
            player.next = createPiece(Math.floor(Math.random() * 7) + 1);
            player.pos.y = 0;
            player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            
            drawNext();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ–∏–≥—Ä—ã—à
            if (collide()) {
                gameOver = true;
                alert('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –í–∞—à —Å—á–µ—Ç: ' + score);
                arena.forEach(row => row.fill(0));
                score = 0;
                level = 1;
                updateScore();
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
        function collide() {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                        (arena[y + o.y] &&
                        arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã —Å –ø–æ–ª–µ–º
        function playerMerge() {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }
        
        // –î–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
        function playerMove(dir) {
            player.pos.x += dir;
            if (collide()) {
                player.pos.x -= dir;
            }
        }
        
        // –í—Ä–∞—â–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
        function playerRotate() {
            const matrix = player.matrix;
            const N = matrix.length;
            
            // –¢—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã
            for (let y = 0; y < N; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            
            // –û–±—Ä–∞—Ç–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ —Å—Ç–æ–ª–±—Ü–æ–≤
            for (let y = 0; y < N; ++y) {
                matrix[y].reverse();
            }
            
            if (collide()) {
                // –û—Ç–º–µ–Ω–∞ –≤—Ä–∞—â–µ–Ω–∏—è
                for (let y = 0; y < N; ++y) {
                    matrix[y].reverse();
                }
                for (let y = 0; y < N; ++y) {
                    for (let x = 0; x < y; ++x) {
                        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                    }
                }
            }
        }
        
        // –ü–∞–¥–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã
        function playerDrop() {
            player.pos.y++;
            if (collide()) {
                player.pos.y--;
                playerMerge();
                arenaSweep();
                playerReset();
            }
            dropCounter = 0;
        }
        
        // –û—á–∏—Å—Ç–∫–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –ª–∏–Ω–∏–π
        function arenaSweep() {
            let lines = 0;
            outer: for (let y = arena.length - 1; y >= 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) {
                    if (arena[y][x] === 0) {
                        continue outer;
                    }
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row);
                ++y;
                
                lines++;
            }
            
            if (lines > 0) {
                // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å—á–µ—Ç–∞
                score += lines * lines * 100 * level;
                level = Math.floor(score / 1000) + 1;
                updateScore();
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç–∞
        function updateScore() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        function setupControls() {
            document.getElementById('left-btn').addEventListener('click', () => playerMove(-1));
            document.getElementById('right-btn').addEventListener('click', () => playerMove(1));
            document.getElementById('down-btn').addEventListener('click', () => playerDrop());
            document.getElementById('rotate-btn').addEventListener('click', () => playerRotate());
            
            // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
            document.addEventListener('keydown', event => {
                if (gameOver) return;
                
                switch (event.key) {
                    case 'ArrowLeft':
                        playerMove(-1);
                        break;
                    case 'ArrowRight':
                        playerMove(1);
                        break;
                    case 'ArrowDown':
                        playerDrop();
                        break;
                    case 'ArrowUp':
                        playerRotate();
                        break;
                }
            });
        }
        
        // –û—Å–Ω–æ–≤–Ω–æ–π –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function update(time = 0) {
            if (gameOver) return;
            
            const deltaTime = time - lastTime;
            lastTime = time;
            
            dropCounter += deltaTime;
            if (dropCounter > dropInterval / level) {
                playerDrop();
            }
            
            draw();
            requestAnimationFrame(update);
        }
        
        // –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Telegram WebApp
        if (window.Telegram && Telegram.WebApp) {
            const tg = Telegram.WebApp;
            
            // –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω
            tg.expand();
            
            // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ç–µ–º—ã –ø–æ–¥ Telegram
            document.body.style.backgroundColor = tg.themeParams.bg_color || '#17212b';
            document.body.style.color = tg.themeParams.text_color || '#ffffff';
            
            // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É –∑–∞–∫—Ä—ã—Ç–∏—è
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '–ó–∞–∫—Ä—ã—Ç—å';
            closeBtn.style.position = 'fixed';
            closeBtn.style.top = '10px';
            closeBtn.style.right = '10px';
            closeBtn.style.padding = '5px 10px';
            closeBtn.style.background = tg.themeParams.button_color || '#2ea6ff';
            closeBtn.style.color = tg.themeParams.button_text_color || '#ffffff';
            closeBtn.style.border = 'none';
            closeBtn.style.borderRadius = '5px';
            closeBtn.onclick = () => tg.close();
            document.body.appendChild(closeBtn);
        }
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        init();
    </script>
</body>
</html>
